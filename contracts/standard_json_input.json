{
  "language": "Solidity",
  "sources": {
    "LearnAndEarnRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\ninterface IERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n    \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n    \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n        (bool success, bytes memory returndata) = target.call(data);\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\nlibrary SafeERC20 {\n    using Address for address;\n    \n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n    \n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n    \n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        require((value == 0) || (token.allowance(address(this), spender) == 0), \"SafeERC20: approve from non-zero to non-zero allowance\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n    \n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\nabstract contract Ownable is Context {\n    address private _owner;\n    \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    \n    constructor(address initialOwner) {\n        _transferOwnership(initialOwner);\n    }\n    \n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    \n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    \n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n    \n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    \n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n    \n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\nabstract contract ReentrancyGuard {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status;\n    \n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n    \n    modifier nonReentrant() {\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n}\n\nabstract contract Pausable is Context {\n    event Paused(address account);\n    event Unpaused(address account);\n    \n    bool private _paused;\n    \n    constructor() {\n        _paused = false;\n    }\n    \n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n    \n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n    \n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n    \n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n    \n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n    \n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n    \n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n\ncontract LearnAndEarnRewards is Ownable, ReentrancyGuard, Pausable {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable goodDollarToken;\n    \n    uint256 public totalDeposited;\n    uint256 public totalDisbursed;\n    uint256 public totalWithdrawn;\n    \n    uint256 public maxDisbursementAmount;\n    uint256 public minDisbursementAmount;\n    \n    mapping(address => uint256) public userTotalRewards;\n    mapping(address => uint256) public userRewardCount;\n    mapping(bytes32 => bool) public processedRewards;\n    \n    event Deposited(address indexed from, uint256 amount, uint256 timestamp);\n    event RewardDisbursed(address indexed recipient, uint256 amount, string quizId, bytes32 rewardId, uint256 timestamp);\n    event Withdrawn(address indexed to, uint256 amount, uint256 timestamp);\n    event MaxDisbursementUpdated(uint256 oldAmount, uint256 newAmount);\n    event MinDisbursementUpdated(uint256 oldAmount, uint256 newAmount);\n    event EmergencyWithdraw(address indexed to, uint256 amount, uint256 timestamp);\n\n    constructor(\n        address _goodDollarToken,\n        uint256 _maxDisbursementAmount,\n        uint256 _minDisbursementAmount\n    ) Ownable(msg.sender) {\n        require(_goodDollarToken != address(0), \"Invalid token address\");\n        require(_maxDisbursementAmount > _minDisbursementAmount, \"Max must be > min\");\n        \n        goodDollarToken = IERC20(_goodDollarToken);\n        maxDisbursementAmount = _maxDisbursementAmount;\n        minDisbursementAmount = _minDisbursementAmount;\n    }\n\n    function deposit(uint256 amount) external nonReentrant whenNotPaused {\n        require(amount > 0, \"Amount must be > 0\");\n        \n        goodDollarToken.safeTransferFrom(msg.sender, address(this), amount);\n        totalDeposited += amount;\n        \n        emit Deposited(msg.sender, amount, block.timestamp);\n    }\n\n    function depositFrom(address from, uint256 amount) external onlyOwner nonReentrant whenNotPaused {\n        require(amount > 0, \"Amount must be > 0\");\n        require(from != address(0), \"Invalid from address\");\n        \n        goodDollarToken.safeTransferFrom(from, address(this), amount);\n        totalDeposited += amount;\n        \n        emit Deposited(from, amount, block.timestamp);\n    }\n\n    function disburseReward(\n        address recipient,\n        uint256 amount,\n        string calldata quizId\n    ) external onlyOwner nonReentrant whenNotPaused returns (bytes32) {\n        require(recipient != address(0), \"Invalid recipient\");\n        require(amount >= minDisbursementAmount, \"Amount below minimum\");\n        require(amount <= maxDisbursementAmount, \"Amount exceeds maximum\");\n        \n        bytes32 rewardId = keccak256(abi.encodePacked(recipient, quizId));\n        require(!processedRewards[rewardId], \"Reward already processed for this quiz\");\n        \n        uint256 balance = goodDollarToken.balanceOf(address(this));\n        require(balance >= amount, \"Insufficient contract balance\");\n        \n        processedRewards[rewardId] = true;\n        userTotalRewards[recipient] += amount;\n        userRewardCount[recipient] += 1;\n        totalDisbursed += amount;\n        \n        goodDollarToken.safeTransfer(recipient, amount);\n        \n        emit RewardDisbursed(recipient, amount, quizId, rewardId, block.timestamp);\n        \n        return rewardId;\n    }\n\n    function batchDisburseRewards(\n        address[] calldata recipients,\n        uint256[] calldata amounts,\n        string[] calldata quizIds\n    ) external onlyOwner nonReentrant whenNotPaused returns (bytes32[] memory) {\n        require(recipients.length == amounts.length, \"Arrays length mismatch\");\n        require(recipients.length == quizIds.length, \"Arrays length mismatch\");\n        require(recipients.length <= 50, \"Batch too large\");\n        \n        uint256 totalAmount = 0;\n        for (uint256 i = 0; i < amounts.length; i++) {\n            totalAmount += amounts[i];\n        }\n        \n        uint256 balance = goodDollarToken.balanceOf(address(this));\n        require(balance >= totalAmount, \"Insufficient contract balance\");\n        \n        bytes32[] memory rewardIds = new bytes32[](recipients.length);\n        \n        for (uint256 i = 0; i < recipients.length; i++) {\n            require(recipients[i] != address(0), \"Invalid recipient\");\n            require(amounts[i] >= minDisbursementAmount, \"Amount below minimum\");\n            require(amounts[i] <= maxDisbursementAmount, \"Amount exceeds maximum\");\n            \n            bytes32 rewardId = keccak256(abi.encodePacked(recipients[i], quizIds[i]));\n            require(!processedRewards[rewardId], \"Reward already processed for this quiz\");\n            \n            processedRewards[rewardId] = true;\n            userTotalRewards[recipients[i]] += amounts[i];\n            userRewardCount[recipients[i]] += 1;\n            totalDisbursed += amounts[i];\n            \n            goodDollarToken.safeTransfer(recipients[i], amounts[i]);\n            \n            rewardIds[i] = rewardId;\n            \n            emit RewardDisbursed(recipients[i], amounts[i], quizIds[i], rewardId, block.timestamp);\n        }\n        \n        return rewardIds;\n    }\n\n    function withdraw(uint256 amount) external onlyOwner nonReentrant {\n        require(amount > 0, \"Amount must be > 0\");\n        \n        uint256 balance = goodDollarToken.balanceOf(address(this));\n        require(balance >= amount, \"Insufficient balance\");\n        \n        totalWithdrawn += amount;\n        goodDollarToken.safeTransfer(owner(), amount);\n        \n        emit Withdrawn(owner(), amount, block.timestamp);\n    }\n\n    function withdrawAll() external onlyOwner nonReentrant {\n        uint256 balance = goodDollarToken.balanceOf(address(this));\n        require(balance > 0, \"No balance to withdraw\");\n        \n        totalWithdrawn += balance;\n        goodDollarToken.safeTransfer(owner(), balance);\n        \n        emit Withdrawn(owner(), balance, block.timestamp);\n    }\n\n    function emergencyWithdraw(address token) external onlyOwner nonReentrant {\n        IERC20 tokenContract = IERC20(token);\n        uint256 balance = tokenContract.balanceOf(address(this));\n        require(balance > 0, \"No balance\");\n        \n        tokenContract.safeTransfer(owner(), balance);\n        \n        emit EmergencyWithdraw(owner(), balance, block.timestamp);\n    }\n\n    function setMaxDisbursementAmount(uint256 newMax) external onlyOwner {\n        require(newMax > minDisbursementAmount, \"Max must be > min\");\n        \n        uint256 oldMax = maxDisbursementAmount;\n        maxDisbursementAmount = newMax;\n        \n        emit MaxDisbursementUpdated(oldMax, newMax);\n    }\n\n    function setMinDisbursementAmount(uint256 newMin) external onlyOwner {\n        require(newMin < maxDisbursementAmount, \"Min must be < max\");\n        \n        uint256 oldMin = minDisbursementAmount;\n        minDisbursementAmount = newMin;\n        \n        emit MinDisbursementUpdated(oldMin, newMin);\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function getContractBalance() external view returns (uint256) {\n        return goodDollarToken.balanceOf(address(this));\n    }\n\n    function getUserStats(address user) external view returns (\n        uint256 totalRewards,\n        uint256 rewardCount\n    ) {\n        return (userTotalRewards[user], userRewardCount[user]);\n    }\n\n    function getContractStats() external view returns (\n        uint256 balance,\n        uint256 deposited,\n        uint256 disbursed,\n        uint256 withdrawn\n    ) {\n        return (\n            goodDollarToken.balanceOf(address(this)),\n            totalDeposited,\n            totalDisbursed,\n            totalWithdrawn\n        );\n    }\n\n    function isRewardProcessed(bytes32 rewardId) external view returns (bool) {\n        return processedRewards[rewardId];\n    }\n\n    function isQuizRewardClaimed(address recipient, string calldata quizId) external view returns (bool) {\n        bytes32 rewardId = keccak256(abi.encodePacked(recipient, quizId));\n        return processedRewards[rewardId];\n    }\n\n    function getRewardId(address recipient, string calldata quizId) external pure returns (bytes32) {\n        return keccak256(abi.encodePacked(recipient, quizId));\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": ["abi", "evm.bytecode", "evm.deployedBytecode"]
      }
    }
  }
}
